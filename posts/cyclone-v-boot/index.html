<!doctype html><html lang=en-us data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Simplified Boot Flow for the Cyclone V | stumbl.ing</title><meta name=description content="Embedded shenanigans: DSP debugging, reverse engineering, and hardware teardowns"><meta name=show-reading-time content="true"><link rel=stylesheet href=/css/main.css><link rel=canonical href=https://stumbl.ing/posts/cyclone-v-boot/><link rel=alternate type=application/rss+xml href=/index.xml title=stumbl.ing><link rel=icon type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=57x57 href=/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.152.2"></head><body><header><div class=container><nav><a href=https://stumbl.ing/ class=site-title>stumbl.ing</a><div class=nav-links><a href=/about/>about</a>
<a href=/projects/>projects</a>
<a href=/posts/>archive</a>
<a href=https://github.com/lockbox>github</a>
<button class=theme-toggle aria-label="Toggle theme">☀️</button></div></nav></div></header><main><div class=container><article><header class=post-header><div class=post-meta><span class=post-date>2024-02-18</span>
<span class=reading-time>4 min read</span></div><h1>Simplified Boot Flow for the Cyclone V</h1></header><div class=post-content><ul><li><a href=#executing-user-software>Executing User Software</a><ul><li><a href=#preloader-image-requirements>PreLoader Image Requirements</a></li><li><a href=#preloader-actions>PreLoader Actions</a></li><li><a href=#preloader-memory-state>PreLoader Memory State</a></li><li><a href=#bootloader-execution--u-boot>Bootloader execution (u-boot)</a></li><li><a href=#operating-system-boot>Operating System Boot</a></li></ul></li></ul><p>The <a href=https://www.intel.com/content/www/us/en/docs/programmable/683126/21-2/hard-processor-system-technical-reference.html>Cyclone V Technical Reference Manual</a>
details the boot flow for the common &ldquo;running linux to boot your FPGA&rdquo; usecase like so:</p><p></p><figure><img src=/images/posts/manual-boot-flow.png alt="Figure 1: Technical Reference Manual Diagram of Typical Boot Flow"><figcaption><p>Figure 1: Technical Reference Manual Diagram of Typical Boot Flow</p></figcaption></figure><p>But because everything after the BootROM is classified as &ldquo;user software,&rdquo; there is not much described in the manual.</p><p>What the manual describes as &ldquo;user software&rdquo; still encompasses an entire software stack built,
maintained, and packaged by Altera, but <strong>can</strong> be overriden by the user. As far as behavior and
code that users cannot overwrite go, we are limited to the BootROM.</p><p>The BootROM is described in short on page <code>A-5</code>, and the state machine is fully diagrammed on
page <code>A-27</code>.</p><ul><li>BootROM is 64kb in size</li><li>Located in on-chip ROM at address range <code>0xFFFD_0000</code> to <code>0xFFFD_FFFF</code></li><li>The purpose is to determine the boot source, initialize the HPS after reset, and jump to the PreLoader</li></ul><p>There is a little more nuance if the PreLoader needs to be loaded from flash into RAM. RTFM for more.</p><h2 id=executing-user-software>Executing User Software</h2><p>The BootROM&rsquo;s entire purpose is to call the PreLoader, and setup the initial environment necessary for
the PreLoader to be able to load the BootLoader (u-boot) which in turn loads the Operating System (Linux).</p><p>Page <code>A-31</code> details the entry state of the processor on calling the PreLoader:</p><ul><li>I-cache disabled</li><li>Branch Predictor enabled</li><li>D cache disabled</li><li>MMU disabled</li><li>FPU enabled</li><li>NEON enabled</li><li>Processor is in ARM <code>supervisor</code> mode</li></ul><p>Register state:</p><ul><li><code>r0</code>: pointer to shared memory block used to pass information to PreLoader (located in top 4kb of on-chip RAM)</li><li><code>r1</code>: length of the shared memory</li><li><code>r2</code>: set to <code>0x0</code></li><li><code>r3</code>: reserved</li></ul><p>Other system state:</p><ul><li>BootROM is mapped to address <code>0x0</code></li><li><code>L4</code> watchdog timer active and toggled</li><li>Reset cause saved to <code>stat</code> register of the Reset Manager</li><li>Shared memory is setup as described in table <code>A-18</code></li></ul><p>Before the PreLoader can actually be executed, the BootROM validates the PreLoader image after mapping
it into memory at address <code>0xFFFF_0000</code> -> <code>0xFFFF_F000</code>.</p><h3 id=preloader-image-requirements>PreLoader Image Requirements</h3><ul><li>Validation word matches magic <code>0x3130_5341</code> (&ldquo;10SA&rdquo;)</li><li>Header version matches</li><li>Header program length (in 32-bit words) from offset 0 to the end of the code area<ul><li>Not including exception vectors or CRC</li></ul></li><li>Checksum of all bytes in the header from offset <code>0x40</code> to <code>0x49</code></li><li>Maximum size of 60 kb (on-chip RAM - 4kb reserved RAM)</li></ul><figure><img src=/images/posts/preloader-image-layout.png alt="Figure 2: PreLoader Image Layout"><figcaption><p>Figure 2: PreLoader Image Layout</p></figcaption></figure><h3 id=preloader-actions>PreLoader Actions</h3><p>The manual very helpfully describes the PreLoader functions as &ldquo;user-defined, however typical functions include &mldr;&rdquo;
But also describes a detailed state machine + order of operations on page <code>A-29</code>.</p><p>TLDR;</p><ul><li>Freeze all I/O banks</li><li>Reset peripherals</li><li>Setup clocks</li><li>Unfreeze all I/O banks</li><li>L3/L4 configuration</li><li>Timer + UART initialization</li><li>SDRAM initialization</li><li>Boot next stage</li></ul><h3 id=preloader-memory-state>PreLoader Memory State</h3><p>Probably the most helpful thing in the manual so far is this image that shows the state of the memory regions.
In the paragraph before this in the manual, it discusses that until the <code>L3</code> interconnect remap bit 0 is
set high, the exception vectors are still pointing to the exceptions handlers provided by the BootROM.
Setting this bit high remaps the on-chip RAM that the PreLoader is executing with into the 0 page to
successfully splat onto the BootROM handlers.</p><figure><img src=/images/posts/preloader-remapping-memory.png alt="Figure 3: Memory state of the Cyclone V HPS before and after executing a (compliant) PreLoader"><figcaption><p>Figure 3: Memory state of the Cyclone V HPS before and after executing a (compliant) PreLoader</p></figcaption></figure><p>Comparing this to the <a href=https://developer.arm.com/documentation/den0013/d/Boot-Code/Booting-a-bare-metal-system>ARM Cortex-A booting a bare-metal system guide</a>, we can
start to see some similarities and start to line things up at least as far as code-layout goes.</p><p>The PreLoader (after settting up the respective peripherals), then calls the BootLoader.</p><h3 id=bootloader-execution--u-boot>Bootloader execution (u-boot)</h3><p>u-boot is going to do a few main things:</p><ul><li>Get loaded at <code>0xFFFF_0000</code></li><li>Load u-boot scripts that are present</li><li>Find the device tree it is supposed to use</li><li>Execute the kernel with the device tree passed as a parameter</li></ul><p>In the default <a href=https://github.com/altera-opensource/u-boot-socfpga/blob/14e5dc0d59381b43979ab059f1de9cf9afe3645a/configs/socfpga_cyclone5_defconfig>provided-from-altera-open-source u-boot configuration</a>,
there are a few things to note in the `KConfig` for the target:</p><ul><li>booting with SPL u-boot (full blown u-boot), with <code>0xFFFF_0000</code> start address</li><li>default malloc len is size <code>0x4000_0000</code> (1GB)</li><li>u-boot expects to be at specific offsets into the SPI flash device memory</li></ul><p>Looking at the <a href=https://github.com/altera-opensource/u-boot-socfpga/blob/14e5dc0d59381b43979ab059f1de9cf9afe3645a/arch/arm/dts/socfpga_cyclone5_socdk.dts>default device-tree</a> (also provided by Altera),
we can get the list of all the device drivers we need to bake into our linux kernel image (via the &ldquo;compatible&rdquo; attribute in each section),
the size of memory via the <code>memory</code> section, and the default peripherals setups of everything else. Note that you can also describe SRAM
by using the <code>sram</code> section (<code>mmio-sram</code> is the correct driver aiui), and the <code>sdram</code> / <code>mmc</code> blocks as well.</p><p>From there, any <code>u-boot</code> scripts or environment will dictate how linux (and your fpga :p) is actually going to get loaded and executed.
Nowadays you&rsquo;ll probably run into a `bootz` (<a href=https://docs.u-boot.org/en/latest/usage/cmd/bootz.html>docs</a>).</p><h3 id=operating-system-boot>Operating System Boot</h3><p>If you get the default zlinux, then it will self unpack into memory, and then execute the `init` command as specified in your
kernel command line environment.</p><p>And it&rsquo;s done and booted! :D</p></div><div class=tag-list><a href=/tags/cyclone class=tag>#cyclone</a>
<a href=/tags/embedded class=tag>#embedded</a>
<a href=/tags/linux class=tag>#linux</a></div><nav class=post-nav><a href=https://stumbl.ing/posts/offline-yubikey/ class=next-post>Offline Yubikey →</a></nav></article></div></main><footer><div class=container><div class=footer-content><div class=footer-links><a href=/index.xml>RSS</a>
<a href=https://github.com/lockbox>GitHub</a>
<a href=https://github.com/struct-foo>struct-foo</a>
<a href=https://infosec.exchange/@lockbox@infosec.exchange>Mastodon</a>
<a href=https://twitter.com/lockbox4141>Twitter</a></div><div class=footer-copy>© 2025 stumbl.ing | stumbling forward</div></div></div></footer><script src=/js/main.js></script></body></html>